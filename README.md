# Тема 9. Концепции и принципы ООП
Отчет по Теме #9 выполнил:
- Рожков Сергей Сергеевич
- ЗПИЭ-20-2

| Задание | Сам_раб |
| ------  | ------ |
| Задание 1 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1
### Задание:<br>Класс Tomato:<br>1) Создайте класс Tomato<br>2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора<br>3) Создайте метод __init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state (принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства<br>4) Создайте метод grow(), который будет переводить томат на следующую стадию созревания<br>5) Создайте метод is_ripe(), который будет проверять, что томат созрел <br>Класс TomatoBush:<br>1) Создайте класс TomatoBush<br>2) Определите метод __init__(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes<br>3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания<br>4) Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.<br>5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая<br>Класс Gardener:<br>1) Создайте класс Gardener<br>2) Создайте метод __init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства<br>3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым<br>4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение<br>5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству<br>Тесты:<br>1) Вызовите справку по садоводству<br>2) Создайте объекты классов TomatoBush и Gardener<br>3) Используя объект класса Gardener, поухаживайте за кустом с помидорами<br>4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними.<br>5) Соберите урожай<br>Результатом работы вашей программы будет листинг кода с подробными комментариями и скриншоты выполнения всех тестов

```python
class Tomato:
    # Статическое свойство со стадиями созревания томатов
    states = ('отсутствует', 'цветение', 'зеленый', 'красный')

    def __init__(self, index):
        # Динамическое свойство, передается параметром
        self._index = index
        # Динамическое свойство, принимает первое значение из списка стадий созревания
        self._state = self.states[0]

    def grow(self):
        # Переводит томат на следующую стадию созревания
        if self._state != self.states[-1]:
            current_state_index = self.states.index(self._state)
            self._state = self.states[current_state_index + 1]

    def is_ripe(self):
        # Проверяет созрел ли томат
        return self._state == self.states[-1]


class TomatoBush:
    def __init__(self, quantity):
        self.tomatoes = []
        # Создает список объектов класса Tomato в зависимости от количества томатов
        for i in range(quantity):
            self.tomatoes.append(Tomato(i))

    def grow_all(self):
        # Переводит все томаты на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        # Возвращает True, если все томаты созрели
        return all([tomato.is_ripe() for tomato in self.tomatoes])

    def give_away_all(self):
        # Очищает список томатов после сбора урожая
        self.tomatoes = []


class Gardener:
    def __init__(self, name, plant):
        # Динамическое свойство, передается параметром
        self.name = name 
        # Динамическое свойство, принимает объект класса TomatoBush
        self._plant = plant

    def work(self):
        # Заставляет садовника работать
        self._plant.grow_all()

    def harvest(self):
        # Проверяет, все ли томаты созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
        if self._plant.all_are_ripe():
            print("Мы собрали урожай")
            self._plant.give_away_all()
        else:
            print("Урожай не созрел")


    def knowledge_base():
        # Выводит справку по садоводству
        print("Садовник должен работать. Садовник не работает - урожай не зреет.")


# Вызов справки по садоводству
Gardener.knowledge_base()

# Создание объектов классов TomatoBush и Gardener
tomato_bush = TomatoBush(150)
gardener = Gardener("Садовник", tomato_bush)

# Уход за кустом с помидорами
gardener.work()

# Попытка собрать урожай, когда томаты еще не созрели
gardener.harvest()

# Уход за кустом с помидорами до созревания всех плодов
for i in range(len(Tomato.states)):
    gardener.work()

# Сбор урожая
gardener.harvest()
```

### Результат
![Консоль]()

## Выводы
Выполняя задание я изучил работу с классами, статическими и динамическими свойствами, методами классов, организацию взаимодействия между разными классами внутри одного кода

## Общие выводы по теме
Выполняя работу по данной теме я узнал как реализовать код с использованием объектов, классов, наследования, инкапсуляции и полиморфизма
